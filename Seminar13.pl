/* 
Kaзваме, че списъкът X e екстерзала/екстерзана за списъка от списъци Y ,
ако X има поне един общ елемент с всички елементи на Y и поне два общи
елемента с нечетен/четен брой елементи на Y Да се дефинира на пролог дву-
местен предикат екстерзала (X, Y ), който по даден списък от списъци Y при
презадоволяване генерира всички екстерзали/екстервали X за Y с възможно
най-малка дължина и спира.


Представяне на кореново дърво T ще наричаме всяка двойка от (V, E), където
V е списък от върховете на T , а E е списък от точно онези двойки (u, v), за
които u е баща на v в T .
За кореново дърво T = (V, E) ще казваме, че балансирано/дълбоко, ако ви-
сочината му не надвишава 2 log2 |V |/ log 2 2|V | .
Да се дефинира на пролог предикат balanced(T )/deep(T ), който по предста-
вяне на кореново дърво проверява дали то е балансирано/дълбоко.


Казваме, че списъкът X от естествени числа e:
1. вариант 1: контракуляр за списъка от списъци от естествени числа Y ,
ако всеки елемент на Y съдържа елемент, който се дели без остатък от
всички елементи на X, а всеки елемент на X се дели без остатък от някой
елемент на елемент на Y .
2. вариант 2: кентракуляр за списъка от списъци от естествени числа Y ,
ако всеки елемент на Y съдържа елемент, който дели без остатък някой
елемент на X, а всеки елемент на X дели без остатък някой елемент на
елемент на Y .
Да се дефинира предикат p(X, Y ), който по даден списък от списъци от
естествени числа Y намира контракуляр X с възможно най-много различни
елементи.


За естествено число n с представяне в 8-ична бройна система n = P
i=0 ∞
 ai 8i
 , където ai ∈
{0, 1, 2, 3, 4, 5, 6, 7}, ще казваме, че е байт-дървовидно тогава и само тогава, когато ако:
• Вариант 1: v = bu/8c и au 6≡ 0 (mod 7), то au ≡ av + 1 (mod 6).
• Вариант 2: v = bu/8c и au 6≡ 0 (mod 6), то av ≡ au + 1 (mod 7).
Да се дефинира на предикат на пролог byteT reeN um(N ), който по дадено естествено число
N проверява дали то е байт-дървовидно.


Ще казваме, че един списък е анаграма на друг, ако е съставен от същите елементи, но
в евентуално различен ред.
Да се дефинира предикат на пролог maxAnagrams(L, M ) на пролог, който по даден
списък от списъци L, генерира в M най-голямото число, за което има поне M на брой:
• M -елементни списъка от L, които са анаграми един на друг.
• (M + 2)-елементни списъка от L, които са анаграми един на друг.


Да се дефинира на Пролог двуместен предикат,
който по дадени две цели числа A, B in Z разпознава дали те имат
едни и същи прости делители.

*/


/* Да се дефинира на пролог предикат p(X, Y),
който по даден списък X от списъци от числа намира та-
къв елемент Y на X, че Y не съдържа по-голям елемент от
най-големите елементи на елементите на X, и никой еле-
мент на X, притежаващ същото свойство, не е с повече
елементи от Y. */

% X = [[1,2], [3,4,2,-1], ..., [1,1]]

max(L, X):- member(X, L), not((member(Y, L), Y > X)).

condition(X, Y):- not((member(Z, Y), member(T, X), max(T, M), Z > M)).

p(X, Y):- member(Y, X), condition(X, Y), length(Y, N), 
            not((member(Z, X), condition(X, Z), length(Z, M), M > N)).


/*   
Да се дефинира на пролог предикат p(L), който
по даден списък от различни списъци L проверява дали
в L съществуват два различни елемента, които имат общ
елемент, който не принадлежи на никой друг елемент на L. */
p(L):- member(X, L), member(Y, L), X \= Y, commonElement(X, Y, Z), 
        not(( member(T, L), T \= X, T \= Y, member(Z, T))).

commonElement(X, Y, Z):- member(Z, X), member(Z, Y).

/* 
Казваме, че списък X мажорира списък Y , ако
всички елементи на X са елементи на Y . Да се дефинира
на пролог предикат p(L, M), който по даден списък от спи-
съци L намира списък M , който съдържа всички елементи
на L и в който никой елемент не се мажорира от елемент,
намиращ се след него в списъка. */

maj(X, Y):- not((member(Z, X), not(member(Z, Y)))).

% p(L, M):- permutation(L, M), not(( append(_, [X|Rest], M), member(Y, Rest), maj(Y, X) )).

/* 
Дърво се нарича краен неориентиран свързан и ацикличен граф. За един спи-
сък от списъци [V, E] ще казваме, че представя неориентирания граф G, ако
V е списък от всички върхове на G и {v, w} е ребро в G тогава и само тогава,
когато [v, w] или [w, v] e eлeмeнт на E.
Да се дефинира на пролог предикат art_tree(V, E)/arc_tree(V, E), който по
дадено представяне [V, E] на краен неориентиран граф разпознава дали има
такава двойка върхове v и w, че [V, E + [v, w]]/[V, E − [v, w]] да е представяне
на дърво, където E + [v, w]/E − [v, w] е списъкът, получен от E с 
добавянето на нов елемент [v, w]/премахването на всички срещания на елемента [v, w]. */

/* 
 краен неориентиран свързан и ацикличен граф;
 краен неориентиран свързан граф и |E| = |V| - 1;
 краен неориентиран ацикличен граф и |E| = |V| - 1;
*/
/* Правим покриващо дърво на графа G и проверяваме, че множеството от ребра се запазва. */

edge(U1, W1, E):- member([U1, W1], E); member([W1, U1], E).

arc_tree(V, E):- member([U, W], E), removeDuplicates(U, W, E, NewE), 
                  spanningTree(V, NewE, TreeE), 
                    not(( edge(U1, W1, NewE), not(edge(U1, W1, TreeE)) )).

removeDuplicates(U, W, E, NewE):-removeAll([U, W], E, NE), removeAll([W, U], NE, NewE).

removeAll(_, [], []).
removeAll(X, [X|T], L):-removeAll(X, T, L).
removeAll(X, [Y|T], [Y|L]):-X\=Y, removeAll(X, T, L).

remove(X, [X|T], T).
remove(X, [Y|T], [Y|L]):-X\=Y, remove(X, T, L).
% stree(E, NVis, Vis, Result)
stree(_, _, [], []).
stree(E, Vis, NVis, [[X, Y]|R]):- member(X, Vis), member(Y, NVis), edge(X, Y, E), remove(Y, NVis, NVisNew), 
    stree(E, [Y|Vis], NVisNew, R).

spanningTree([], _, []).
spanningTree([X|V], E, TreeE):-stree(E, [X], V, TreeE).

graph([[0, 1, 2, 3, 4], [[0,1], [1, 2], [2,4], [4, 2], [2, 3], [4, 1]]]).

/* 
I.1 Редиците на Фарей, Fn , са редици от двойки естествени числа, които
се дефинират рекурсивно за n ≥ 1 по следния начин:
• F1 = [[0, 1], [1, 1]];
• Fn+1 се получава от Fn , като между всеки два последователни члена
[a, b] и [c, d] на Fn, за които b+d = n+1, се добавя двойката [a+c, n+1].
Да се дефинира на пролог едноместен предикат farey(F), който при пре-
удовлетворяване генерира в F всички редици на Фарей. */

farey(L):- generateFarey(L, _).

generateFarey([[0, 1], [1, 1]], 1).
generateFarey(FNP1, NP1):- generateFarey(FN, N), NP1 is N + 1, addPairsFarey(FN, NP1, FN).

addPairsFarey([X], _, [X]).
addPairsFarey([[A, B], [C, D]|T], NP1, [[A, B], [APC, NP1]|R]):- B + D =:= NP1, 
                    APC is A + C, addPairsFarey([[C, D]|T], NP1, R).
addPairsFarey([[A, B], [C, D]|T], NP1, [[A, B]|R]):- B + D =\= NP1, 
                    addPairsFarey([[C, D]|T], NP1, R).


/* 
Ще казваме, че един списък е анаграма на друг, ако е съставен от същите елементи, но
в евентуално различен ред.
Да се дефинира предикат на пролог maxAnagrams(L, M), който по даден
списък от списъци L, генерира в M най-голямото число, за което има поне M на брой 
M-елементни списъка от L, които са анаграми един на друг. */

subsequence([], []).
subsequence([H|T], [H|R]):- subsequence(T, R).
subsequence([_|T], R):- subsequence(T, R).

condition(S, M):- not(( member(X, S), length(X, K), K =\= M)).

anagrams([]).
anagrams([_]).
anagrams([A, B|T]):- permutation(A, B), anagrams([B|T]).

generateWitness(L, M, S):- length(L, LL), between(0, LL, M), 
                    subsequence(L, S), length(S, M1), M1 >= M, condition(S, M), anagrams(S).

maxAnagrams(L, M, S):- generateWitness(L, M, S), not(( generateWitness(L, N, _), N > M )).


/* 
Казваме, че списъкът X от естествени числа e:
контракуляр за списъка от списъци от естествени числа Y ,
ако всеки елемент на Y съдържа елемент, който се дели без остатък от
всички елементи на X, а всеки елемент на X се дели без остатък от някой
елемент на елемент на Y .
Да се дефинира предикат p(X, Y), който по даден списък от списъци от
естествени числа Y намира контракуляр X с възможно най-много различни
елементи. */

generateWitness(Y, X):- flatten(Y, FY), 

contraculyar(X, Y):- generateWitness(Y, X), condition1(X, Y), condition2(X, Y).

condition1(X, Y):- not(( member(Z, Y), not(( member(T, Z), divAll(X, T) )))).

condition2(X, Y):- not(( member(Z, X), not(( member(T, Y), member(U, T), Z mod U =:= 0)))).

divAll(X, T):- not((member(U, X), T mod U =\= 0)).